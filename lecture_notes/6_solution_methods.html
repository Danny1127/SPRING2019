<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
  <head>
    <title>Solution methods for dynamic economic models</title>
    <meta charset="utf-8" />
    <meta name="author" content="Ivan Rudik" />
    <link href="libs/remark-css-0.0.1/default.css" rel="stylesheet" />
    <link href="libs/remark-css-0.0.1/metropolis.css" rel="stylesheet" />
    <link href="libs/remark-css-0.0.1/metropolis-fonts.css" rel="stylesheet" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# Solution methods for dynamic economic models
## <html>
<div style="float:left">

</div>
<hr color='#459DE0' size=5px width=1100px>
</html>
### Ivan Rudik
### AEM 7130

---


# Roadmap

1. How do we think about solving dynamic economic models
2. Value function iteration
3. Fixed point iteration
4. Time iteration

--

Things to do:

1. Install: `LinearAlgebra, Optim, Plots, Roots`
2. Keep in mind that for VFI and TI we will be using optimization/rootfinding packages
  + This matters because these packages typically only let the functions they work on have one input: the guesses for the maximizing input or root
  + We get around this by expressing the function as a *closure*
      + i.e. declare the function inside of a wrapper function that does the maximization/rootfinding so it can access the parameters in the wrapper function
3. Keep in mind we will be working with about the simplest example possible,  
more complex problems will be more difficult to solve

---

# Solutions to economic models

How do we solve economic models?

--

First, what do we want?

--

We want to be able to compute things like optimal policy trajectories, welfare, etc

--

There are generally two objects that can deliver what we want:

1. Value functions
2. Policy functions

--

The idea behind the most commonly used solution concepts is  
to recover good approximations to one of these two functions

--

We recover these functions by exploiting two things:

1. Dynamic equilibrium conditions incorporating these functions (e.g. Bellman equations, Euler equations)
2. Fixed points

--

First lets look at recovering the value function

---

# Our general example

Consider the following problem we will be using for all of these solution methods:
`\begin{gather}
	\max_{\left\{c_t \right\}_{t=0}^\infty} \sum_{t=1}^\infty \beta^t u(c_t) \notag \\
	 \text{subject to:} \,\,\,\,\, k_{t+1} = f(k_t) - c_t \notag 
\end{gather}`
where both consumption and time `\(t+1\)` capital are positive, `\(k(0) = k_0\)`, `\(\alpha &gt; 0\)`, and `\(\beta \in (0,1)\)`

--

Represent the growth model as a Bellman equation
`\begin{gather}
	V(k) = \max_{c}  u(c) + \beta V(k') \notag \\
	 \text{subject to:} \,\,\,\,\, k' = f(k) - c \notag 
\end{gather}`

--

we can reduce this to
`$$V(k) = \max_{c}  u(c) + \beta V(f(k) - c)$$`

---

# Method 1: Value function iteration

In VFI we approximate the *value function* with some flexible functional form `\(\Gamma(k_t;b)\)` where `\(b\)` is a vector of coefficients

--

The algorithm:

1. Select the number of collocation points in each dimension and the domain of the approximation space
2. Select an initial vector of coefficients `\(b_0\)` with the same number of elements as the collocation grid,  
and initial guesses for consumption for the solver
3. Select a rule for convergence
4. Construct the grid and basis matrix
5. While convergence criterion `\(&gt;\)` tolerance
  + Start iteration `\(p\)`
  + Solve the right hand side of the Bellman equation using the  
  value function approximant `\(\Gamma(k_{t+1};b^{(p)})\)` in place of `\(V(k_{t+1})\)`
  + Recover the maximized values, conditional on the approximant
  + Fit the polynomial to the values and recover a new vector of coefficients `\(\hat{b}^{(p+1)}\)`.
  + Compute the vector of coefficients `\(b^{(p+1)}\)` for iteration `\(p+1\)` by  
  `\(b^{(p+1)} = (1-\gamma) b^{(p)} + \gamma \hat{b}^{(p+1)}\)` where `\(\gamma \in (0,1).\)` (damping)
  + Use the optimal controls for this iteration as our initial guess for next iteration
6. Error check your approximation

---

# Step 1: Select the number of points and domain
- `\(u(c_t) = c_t^{1-\eta}/(1-\eta)\)`
- `\(f(k_t) = k_t^\alpha\)`
- `\(\alpha = 0.75\)`
- `\(\beta = 0.95\)`
- `\(\eta = 2\)`
- `\(k_0 = (\alpha \beta)^{1/(1-\alpha)}/2\)`

--

Put everything in a **named tuple** to make passing things easier


```julia
using LinearAlgebra, Optim, Plots 
params = (alpha = 0.75, beta = 0.95, eta = 2,
                steady_state = (0.75*0.95)^(1/(1 - 0.75)), k_0 = (0.75*0.95)^(1/(1 - 0.75))*.75,
                capital_upper = (0.75*0.95)^(1/(1 - 0.75))*1.5, capital_lower = (0.75*0.95)^(1/(1 - 0.75))/2,
                num_points = 7, tolerance = 0.0001)
```

```
## (alpha = 0.75, beta = 0.95, eta = 2, steady_state = 0.25771486816406236, k_0 = 0.19328615112304676, capital_upper = 0.3865723022460935, capital_lower = 0.12885743408203118, num_points = 7, tolerance = 0.0001)
```

---

# Step 2: Select an initial vector of coefficients `\(b_0\)`


```julia
coefficients = .1*ones(params.num_points)
```

```
## 7-element Array{Float64,1}:
##  0.1
##  0.1
##  0.1
##  0.1
##  0.1
##  0.1
##  0.1
```

---

# Step 3: Select a convergence rule

Rule: maximum change in value on the grid &lt; 0.001%

---

# Step 4: Construct the grid and matrix of basis functions


```julia
function cheb_nodes(n)
    nodes = [cos.(pi * (2k - 1)/(2n)) for k = 1:n]
end;
grid = cheb_nodes(params.num_points) # [-1, 1] grid
```

```
## 7-element Array{Float64,1}:
##   0.9749279121818236   
##   0.7818314824680298   
##   0.4338837391175582   
##   6.123233995736766e-17
##  -0.43388373911755806  
##  -0.7818314824680295   
##  -0.9749279121818237
```

```julia
capital_grid = (1 .+ grid)*(params.capital_upper - params.capital_lower)/2 .+ params.capital_lower # actual capital grid
```

```
## 7-element Array{Float64,1}:
##  0.38334157734276386
##  0.3584596668794432 
##  0.31362401347666824
##  0.2577148681640623 
##  0.2018057228514564 
##  0.15697006944868153
##  0.13208815898536072
```

---

# Step 4: Construct the grid and basis matrix


```julia
# Chebyshev polynomial function
function cheb_polys(x, n)
    if n == 0
        return 1                    # T_0(x) = 1
    elseif n == 1
        return x                    # T_1(x) = x
    else
        cheb_recursion(x, n) =
            2x.*cheb_polys.(x, n - 1) .- cheb_polys.(x, n - 2)
        return cheb_recursion(x, n) # T_n(x) = 2xT_{n-1}(x) - T_{n-2}(x)
    end
end;
```

---

# Step 4a: Pre-invert your basis matrix

Hot tip: you will be using the exact same basis matrix in each loop iteration: just pre-invert it to save time


```julia
basis_matrix = [cheb_polys.(grid, n) for n = 0:params.num_points - 1];
basis_matrix = hcat(basis_matrix...)
```

```
## 7×7 Array{Float64,2}:
##  1.0   0.974928      0.900969  …   0.62349    0.433884      0.222521
##  1.0   0.781831      0.222521     -0.900969  -0.974928     -0.62349 
##  1.0   0.433884     -0.62349      -0.222521   0.781831      0.900969
##  1.0   6.12323e-17  -1.0           1.0        3.06162e-16  -1.0     
##  1.0  -0.433884     -0.62349      -0.222521  -0.781831      0.900969
##  1.0  -0.781831      0.222521  …  -0.900969   0.974928     -0.62349 
##  1.0  -0.974928      0.900969      0.62349   -0.433884      0.222521
```

```julia
basis_inverse = basis_matrix\I
```

```
## 7×7 Array{Float64,2}:
##  0.142857    0.142857    0.142857   …   0.142857    0.142857    0.142857 
##  0.278551    0.22338     0.123967      -0.123967   -0.22338    -0.278551 
##  0.25742     0.0635774  -0.17814       -0.17814     0.0635774   0.25742  
##  0.22338    -0.123967   -0.278551       0.278551    0.123967   -0.22338  
##  0.17814    -0.25742    -0.0635774     -0.0635774  -0.25742     0.17814  
##  0.123967   -0.278551    0.22338    …  -0.22338     0.278551   -0.123967 
##  0.0635774  -0.17814     0.25742        0.25742    -0.17814     0.0635774
```

---

# Step 5: Loop

Construct a function that loops over the grid points and solves the Bellman given `\(\Gamma(x;b^{(p)})\)`


```julia
function loop_grid(params, basis_inverse, basis_matrix, grid, capital_grid, coefficients)

    max_value = -.0*ones(params.num_points);
    scale_capital(capital) = 2*(capital - params.capital_lower)/(params.capital_upper - params.capital_lower) - 1

    # Compute next period's consumption from the Euler equation
    for (iteration, capital) in enumerate(capital_grid)

        function bellman(consumption)
            capital_next = capital^params.alpha - consumption
            capital_next_scaled = scale_capital(capital_next)
            cont_value = coefficients' * [cheb_polys.(capital_next_scaled, n) for n = 0:params.num_points - 1]
            value_out = (consumption)^(1-params.eta)/(1-params.eta) + params.beta*cont_value
            return -value_out
        end;

        results = optimize(bellman, 0.00*capital^params.alpha, 0.99*capital^params.alpha)

        # Compute new value
        max_value[iteration] = -Optim.minimum(results)
    end

    return max_value
end
```

```
## loop_grid (generic function with 1 method)
```

---

# Step 5: Loop


```julia
function solve_vfi(params, basis_inverse, basis_matrix, grid, capital_grid, coefficients)
    iteration = 1
    error = 1e10;
    max_value = -.0*ones(params.num_points);
    value_prev = .1*ones(params.num_points);
    coefficients_store = Vector{Vector}(undef, 1)
    coefficients_store[1] = coefficients
    while error &gt; params.tolerance
        max_value = loop_grid(params, basis_inverse, basis_matrix, grid, capital_grid, coefficients)
        coefficients = basis_inverse*max_value # \Psi \ y
        error = maximum(abs.((max_value - value_prev)./(value_prev)))
        value_prev = deepcopy(max_value)
        if mod(iteration, 5) == 0
            println("Maximum Error of $(error) on iteration $(iteration).")
            append!(coefficients_store, [coefficients])
        end
        iteration += 1
    end
    return coefficients, max_value, coefficients_store
end
```

```
## solve_vfi (generic function with 1 method)
```

---

# Step 5: Loop


```julia
solution_coeffs, max_value, intermediate_coefficients = 
    solve_vfi(params, basis_inverse, basis_matrix, grid, capital_grid, coefficients)
```

```
## Maximum Error of 0.2737801075761883 on iteration 5.
## Maximum Error of 10.181402299701638 on iteration 10.
## Maximum Error of 0.24010896371104573 on iteration 15.
## Maximum Error of 0.08969271235173859 on iteration 20.
## Maximum Error of 0.04951271957737897 on iteration 25.
## Maximum Error of 0.031335744632027096 on iteration 30.
## Maximum Error of 0.02124544109347175 on iteration 35.
## Maximum Error of 0.015000169652694507 on iteration 40.
## Maximum Error of 0.010869867868583969 on iteration 45.
## Maximum Error of 0.008016830712855458 on iteration 50.
## Maximum Error of 0.0059861989167673026 on iteration 55.
## Maximum Error of 0.004509877146521781 on iteration 60.
## Maximum Error of 0.0034198806821233935 on iteration 65.
## Maximum Error of 0.0026059187406616727 on iteration 70.
## Maximum Error of 0.001992913806429802 on iteration 75.
## Maximum Error of 0.001528298601676595 on iteration 80.
## Maximum Error of 0.0011744475125273625 on iteration 85.
## Maximum Error of 0.0009039617707066463 on iteration 90.
## Maximum Error of 0.0006966193080105799 on iteration 95.
## Maximum Error of 0.0005373371780118751 on iteration 100.
## Maximum Error of 0.00041477290357942395 on iteration 105.
## Maximum Error of 0.0003203422150018359 on iteration 110.
## Maximum Error of 0.0002475159621255567 on iteration 115.
## Maximum Error of 0.00019130889470004935 on iteration 120.
## Maximum Error of 0.00014790315766932002 on iteration 125.
## Maximum Error of 0.00011436811226017789 on iteration 130.
```

```
## ([-194.522, 14.1413, -2.66324, 0.575256, -0.134034, 0.0344675, -0.00799708], [-182.756, -184.216, -187.237, -191.985, -198.441, -205.762, -211.259], Array{T,1} where T[[0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1], [46.5073, 7.85518, -1.59278, 0.349952, -0.078987, 0.0174254, -0.00346848], [-7.65552, 12.297, -2.38151, 0.525487, -0.124571, 0.0307752, -0.00663628], [-50.0685, 13.6042, -2.58269, 0.562034, -0.132302, 0.0337529, -0.00764398], [-82.8567, 13.9846, -2.63927, 0.571235, -0.133559, 0.0342889, -0.00789938], [-108.206, 14.0957, -2.65616, 0.574042, -0.133889, 0.034416, -0.00796877], [-127.813, 14.1281, -2.66118, 0.574898, -0.133991, 0.0344524, -0.00798883], [-142.982, 14.1375, -2.66264, 0.575151, -0.134022, 0.0344631, -0.00799468], [-154.718, 14.1402, -2.66307, 0.575226, -0.134031, 0.0344662, -0.00799639], [-163.8, 14.141, -2.66319, 0.575247, -0.134033, 0.0344671, -0.00799688]  …  [-190.871, 14.1413, -2.66324, 0.575256, -0.134034, 0.0344675, -0.00799708], [-191.774, 14.1413, -2.66324, 0.575256, -0.134034, 0.0344675, -0.00799708], [-192.472, 14.1413, -2.66324, 0.575256, -0.134034, 0.0344675, -0.00799708], [-193.013, 14.1413, -2.66324, 0.575256, -0.134034, 0.0344675, -0.00799708], [-193.431, 14.1413, -2.66324, 0.575256, -0.134034, 0.0344675, -0.00799708], [-193.755, 14.1413, -2.66324, 0.575256, -0.134034, 0.0344675, -0.00799708], [-194.006, 14.1413, -2.66324, 0.575256, -0.134034, 0.0344675, -0.00799708], [-194.2, 14.1413, -2.66324, 0.575256, -0.134034, 0.0344675, -0.00799708], [-194.35, 14.1413, -2.66324, 0.575256, -0.134034, 0.0344675, -0.00799708], [-194.466, 14.1413, -2.66324, 0.575256, -0.134034, 0.0344675, -0.00799708]])
```

---

# Now lets plot our solutions


```julia
scale_capital(capital) = 2*(capital - params.capital_lower)/(params.capital_upper - params.capital_lower) - 1
```

```
## scale_capital (generic function with 1 method)
```

```julia
capital_levels = range(params.capital_lower, params.capital_upper, length = 100);
eval_points = scale_capital.(capital_levels);

solution = similar(intermediate_coefficients);

# Compute optimal value at all capital grid points
for (iteration, coeffs) in enumerate(intermediate_coefficients)
    solution[iteration] = [coeffs' * [cheb_polys.(capital, n) for n = 0:params.num_points - 1] for capital in eval_points];
end
```

---

# Plot the value function iterations

&lt;img src="6_solution_methods_files/figure-html/unnamed-chunk-10-J1.png" width="800" /&gt;

---

# Plot the value function iterations

&lt;img src="6_solution_methods_files/figure-html/unnamed-chunk-11-J1.png" width="800" /&gt;

---

# Plot the value function iterations

&lt;img src="6_solution_methods_files/figure-html/unnamed-chunk-12-J1.png" width="800" /&gt;

---

# Plot the value function iterations

&lt;img src="6_solution_methods_files/figure-html/unnamed-chunk-13-J1.png" width="800" /&gt;

---

# Plot the value function iterations

&lt;img src="6_solution_methods_files/figure-html/unnamed-chunk-14-J1.png" width="800" /&gt;

---

# Plot the value function iterations

&lt;img src="6_solution_methods_files/figure-html/unnamed-chunk-15-J1.png" width="800" /&gt;

---

# Plot the value function iterations

&lt;img src="6_solution_methods_files/figure-html/unnamed-chunk-16-J1.png" width="800" /&gt;

---

# Plot the value function iterations

&lt;img src="6_solution_methods_files/figure-html/unnamed-chunk-17-J1.png" width="800" /&gt;

---

# Plot the value function iterations

&lt;img src="6_solution_methods_files/figure-html/unnamed-chunk-18-J1.png" width="800" /&gt;

---

# Plot the final value function

&lt;img src="6_solution_methods_files/figure-html/unnamed-chunk-19-J1.png" width="800" /&gt;

---

# Now lets try simulating


```julia
function simulate_model(params, solution_coeffs, time_horizon = 100)
    capital_store = zeros(time_horizon + 1)
    consumption_store = zeros(time_horizon)
    capital_store[1] = params.k_0
    
    for t = 1:time_horizon
        capital = capital_store[t]
        function bellman(consumption)
            capital_next = capital^params.alpha - consumption
            capital_next_scaled = scale_capital(capital_next)
            cont_value = solution_coeffs' * [cheb_polys.(capital_next_scaled, n) for n = 0:params.num_points - 1]
            value_out = (consumption)^(1-params.eta)/(1-params.eta) + params.beta*cont_value
            return -value_out
        end;

        results = optimize(bellman, 0.0, capital^params.alpha)

        # Compute new value
        consumption_store[t] = Optim.minimizer(results)
        capital_store[t+1] = capital^params.alpha - consumption_store[t]
    end

    return consumption_store, capital_store
end;
```

---

# Now lets try simulating

&lt;img src="6_solution_methods_files/figure-html/unnamed-chunk-21-J1.png" width="800" /&gt;

---

# The consumption policy function


```julia
capital_levels = range(params.capital_lower, params.capital_upper, length = 100);
consumption = similar(capital_levels);

# Compute optimal consumption at all capital grid points
for (iteration, capital) in enumerate(capital_levels)

    function bellman(consumption)
        capital_next = capital^params.alpha - consumption
        capital_next_scaled = scale_capital(capital_next)
        cont_value = solution_coeffs' * [cheb_polys.(capital_next_scaled, n) for n = 0:params.num_points - 1]
        value_out = (consumption)^(1-params.eta)/(1-params.eta) + params.beta*cont_value
        return -value_out
    end

    results = optimize(bellman, 0., capital^params.alpha)

    consumption[iteration] = Optim.minimizer(results)
end;
```

---

# The consumption policy function

&lt;img src="6_solution_methods_files/figure-html/unnamed-chunk-23-J1.png" width="800" /&gt;

---

# Method 2: Fixed point iteration

In FPI we generally approximate a *policy function* with some flexible functional form `\(\Gamma(k_t;b)\)` where `\(b\)` is a vector of coefficients

--

FPI re-casts equilibrium conditions of the model as a fixed point

--

We then perform multi-dimensional function iteration to solve for the fixed point

--

This ends up being very simple and it works on any dimension function

--

It is also does not bear a terrible computational cost and is derivative-free

--

The drawback is that it will not always converge and is generally unstable

--

This can be solved by **damping**


---

# Eq condition: Euler equation

Often we will iterate on the Euler equation which for our problem is
`$$u'(c_t) = \beta u'(c_{t+1}) f'(k_{t+1})$$`

--

We need to put this in a fixed point form in order to iterate on it
`$$c_t = u'^{(-1)}\left(\beta u'(c_{t+1}) f'(k_{t+1})\right)$$`

--

How do we solve this?

--

We approximate the consumption policy function `\(c_{t} = C(k_t)\)` with some flexible functional form `\(\Psi(k_t; b)\)`

--

We have defined `\(c_{t}\)` in two ways, once as an outcome of the policy function, and once as an equilibrium condition

--

Now we can form our consumption policy function as a fixed point by substituting `\(C(k_t)\)` into the the Euler fixed point as follows
`$$C(k_t) = u'^{(-1)}\left(\beta u'(C(k_{t+1})) f'(k_{t+1}(C(k_t),k_t))\right)$$`
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "bash",
"highlightLines": true,
"countIncrementalSlides": false,
"ratio": "16:9"
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();</script>

<script>
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
