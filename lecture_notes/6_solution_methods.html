<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
  <head>
    <title>Solution methods for dynamic economic models</title>
    <meta charset="utf-8" />
    <meta name="author" content="Ivan Rudik" />
    <link href="libs/remark-css-0.0.1/default.css" rel="stylesheet" />
    <link href="libs/remark-css-0.0.1/metropolis.css" rel="stylesheet" />
    <link href="libs/remark-css-0.0.1/metropolis-fonts.css" rel="stylesheet" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# Solution methods for dynamic economic models
## <html>
<div style="float:left">

</div>
<hr color='#459DE0' size=5px width=1100px>
</html>
### Ivan Rudik
### AEM 7130

---


# Roadmap

1. How do we think about solving dynamic economic models
2. Value function iteration
3. Fixed point iteration
4. Time iteration

--

Things to do:

1. Install: `LinearAlgebra, Optim, Plots, Roots`
2. Keep in mind that for VFI and TI we will be using optimization/rootfinding packages
  + This matters because these packages typically only let the functions they work on have one input: the guesses for the maximizing input or root
  + We get around this by expressing the function as a *closure*
      + i.e. declare the function inside of a wrapper function that does the maximization/rootfinding so it can access the parameters in the wrapper function
3. Keep in mind we will be working with about the simplest example possible,  
more complex problems will be more difficult to solve

---

# Solutions to economic models

How do we solve economic models?

--

First, what do we want?

--

We want to be able to compute things like optimal policy trajectories, welfare, etc

--

There are generally two objects that can deliver what we want:

1. Value functions
2. Policy functions

--

The idea behind the most commonly used solution concepts is  
to recover good approximations to one of these two functions

--

We recover these functions by exploiting two things:

1. Dynamic equilibrium conditions incorporating these functions (e.g. Bellman equations, Euler equations)
2. Fixed points

--

First lets look at recovering the value function

---

# Our general example

Consider the following problem we will be using for all of these solution methods:
`\begin{gather}
	\max_{\left\{c_t \right\}_{t=0}^\infty} \sum_{t=1}^\infty \beta^t u(c_t) \notag \\
	 \text{subject to:} \,\,\,\,\, k_{t+1} = f(k_t) - c_t \notag 
\end{gather}`
where both consumption and time `\(t+1\)` capital are positive, `\(k(0) = k_0\)`, `\(\alpha &gt; 0\)`, and `\(\beta \in (0,1)\)`

--

Represent the growth model as a Bellman equation
`\begin{gather}
	V(k) = \max_{c}  u(c) + \beta V(k') \notag \\
	 \text{subject to:} \,\,\,\,\, k' = f(k) - c \notag 
\end{gather}`

--

we can reduce this to
`$$V(k) = \max_{c}  u(c) + \beta V(f(k) - c)$$`

---

# Method 1: Value function iteration

In VFI we approximate the *value function* with some flexible functional form `\(\Gamma(k_t;b)\)` where `\(b\)` is a vector of coefficients

--

The algorithm:

1. Select the number of collocation points in each dimension and the domain of the approximation space
2. Select an initial vector of coefficients `\(b_0\)` with the same number of elements as the collocation grid,  
and initial guesses for consumption for the solver
3. Select a rule for convergence
4. Construct the grid and basis matrix
5. While convergence criterion `\(&gt;\)` tolerance
  + Start iteration `\(p\)`
  + Solve the right hand side of the Bellman equation using the  
  value function approximant `\(\Gamma(k_{t+1};b^{(p)})\)` in place of `\(V(k_{t+1})\)`
  + Recover the maximized values, conditional on the approximant
  + Fit the polynomial to the values and recover a new vector of coefficients `\(\hat{b}^{(p+1)}\)`.
  + Compute the vector of coefficients `\(b^{(p+1)}\)` for iteration `\(p+1\)` by  
  `\(b^{(p+1)} = (1-\gamma) b^{(p)} + \gamma \hat{b}^{(p+1)}\)` where `\(\gamma \in (0,1).\)` (damping)
  + Use the optimal controls for this iteration as our initial guess for next iteration
6. Error check your approximation

---

# Step 1: Select the number of points and domain
- `\(u(c_t) = c_t^{1-\eta}/(1-\eta)\)`
- `\(f(k_t) = k_t^\alpha\)`
- `\(\alpha = 0.75\)`
- `\(\beta = 0.95\)`
- `\(\eta = 2\)`
- `\(k_0 = (\alpha \beta)^{1/(1-\alpha)}/2\)`

--

Put everything in a **named tuple** to make passing things easier


```julia
using LinearAlgebra, Optim, Plots 
params = (alpha = 0.75, beta = 0.95, eta = 2,
                steady_state = (0.75*0.95)^(1/(1 - 0.75)), k_0 = (0.75*0.95)^(1/(1 - 0.75))*.75,
                capital_upper = (0.75*0.95)^(1/(1 - 0.75))*1.5, capital_lower = (0.75*0.95)^(1/(1 - 0.75))/2,
                num_points = 7, tolerance = 0.0001)
```

```
## (alpha = 0.75, beta = 0.95, eta = 2, steady_state = 0.25771486816406236, k_0 = 0.19328615112304676, capital_upper = 0.3865723022460935, capital_lower = 0.12885743408203118, num_points = 7, tolerance = 0.0001)
```

---

# Step 2: Select an initial vector of coefficients `\(b_0\)`


```julia
coefficients = .1*ones(params.num_points)
```

```
## 7-element Array{Float64,1}:
##  0.1
##  0.1
##  0.1
##  0.1
##  0.1
##  0.1
##  0.1
```

---

# Step 3: Select a convergence rule

Rule: maximum change in value on the grid &lt; 0.001%

---

# Step 4: Construct the grid and matrix of basis functions


```julia
function cheb_nodes(n)
    nodes = [cos.(pi * (2k - 1)/(2n)) for k = 1:n]
end;
grid = cheb_nodes(params.num_points) # [-1, 1] grid
```

```
## 7-element Array{Float64,1}:
##   0.9749279121818236   
##   0.7818314824680298   
##   0.4338837391175582   
##   6.123233995736766e-17
##  -0.43388373911755806  
##  -0.7818314824680295   
##  -0.9749279121818237
```

```julia
capital_grid = (1 .+ grid)*(params.capital_upper - params.capital_lower)/2 .+ params.capital_lower # actual capital grid
```

```
## 7-element Array{Float64,1}:
##  0.38334157734276386
##  0.3584596668794432 
##  0.31362401347666824
##  0.2577148681640623 
##  0.2018057228514564 
##  0.15697006944868153
##  0.13208815898536072
```

---

# Step 4: Construct the grid and basis matrix


```julia
# Chebyshev polynomial function
function cheb_polys(x, n)
    if n == 0
        return 1                    # T_0(x) = 1
    elseif n == 1
        return x                    # T_1(x) = x
    else
        cheb_recursion(x, n) =
            2x.*cheb_polys.(x, n - 1) .- cheb_polys.(x, n - 2)
        return cheb_recursion(x, n) # T_n(x) = 2xT_{n-1}(x) - T_{n-2}(x)
    end
end;
```

---

# Step 4a: Pre-invert your basis matrix

Hot tip: you will be using the exact same basis matrix in each loop iteration: just pre-invert it to save time


```julia
basis_matrix = [cheb_polys.(grid, n) for n = 0:params.num_points - 1];
basis_matrix = hcat(basis_matrix...)
```

```
## 7×7 Array{Float64,2}:
##  1.0   0.974928      0.900969  …   0.62349    0.433884      0.222521
##  1.0   0.781831      0.222521     -0.900969  -0.974928     -0.62349 
##  1.0   0.433884     -0.62349      -0.222521   0.781831      0.900969
##  1.0   6.12323e-17  -1.0           1.0        3.06162e-16  -1.0     
##  1.0  -0.433884     -0.62349      -0.222521  -0.781831      0.900969
##  1.0  -0.781831      0.222521  …  -0.900969   0.974928     -0.62349 
##  1.0  -0.974928      0.900969      0.62349   -0.433884      0.222521
```

```julia
basis_inverse = basis_matrix\I
```

```
## 7×7 Array{Float64,2}:
##  0.142857    0.142857    0.142857   …   0.142857    0.142857    0.142857 
##  0.278551    0.22338     0.123967      -0.123967   -0.22338    -0.278551 
##  0.25742     0.0635774  -0.17814       -0.17814     0.0635774   0.25742  
##  0.22338    -0.123967   -0.278551       0.278551    0.123967   -0.22338  
##  0.17814    -0.25742    -0.0635774     -0.0635774  -0.25742     0.17814  
##  0.123967   -0.278551    0.22338    …  -0.22338     0.278551   -0.123967 
##  0.0635774  -0.17814     0.25742        0.25742    -0.17814     0.0635774
```

---

# Step 5: Loop

Construct a function that loops over the grid points and solves the Bellman given `\(\Gamma(x;b^{(p)})\)`


```julia
function loop_grid(params, basis_inverse, basis_matrix, grid, capital_grid, coefficients)

    max_value = -.0*ones(params.num_points);
    scale_capital(capital) = 2*(capital - params.capital_lower)/(params.capital_upper - params.capital_lower) - 1

    # Compute next period's consumption from the Euler equation
    for (iteration, capital) in enumerate(capital_grid)

        function bellman(consumption)
            capital_next = capital^params.alpha - consumption
            capital_next_scaled = scale_capital(capital_next)
            cont_value = coefficients' * [cheb_polys.(capital_next_scaled, n) for n = 0:params.num_points - 1]
            value_out = (consumption)^(1-params.eta)/(1-params.eta) + params.beta*cont_value
            return -value_out
        end;

        results = optimize(bellman, 0.00*capital^params.alpha, 0.99*capital^params.alpha)

        # Compute new value
        max_value[iteration] = -Optim.minimum(results)
    end

    return max_value
end
```

```
## loop_grid (generic function with 1 method)
```

---

# Step 5: Loop


```julia
function solve_vfi(params, basis_inverse, basis_matrix, grid, capital_grid, coefficients)
    iteration = 1
    error = 1e10;
    max_value = -.0*ones(params.num_points);
    value_prev = .1*ones(params.num_points);
    coefficients_store = Vector{Vector}(undef, 1)
    coefficients_store[1] = coefficients
    while error &gt; params.tolerance
        max_value = loop_grid(params, basis_inverse, basis_matrix, grid, capital_grid, coefficients)
        coefficients = basis_inverse*max_value # \Psi \ y
        error = maximum(abs.((max_value - value_prev)./(value_prev)))
        value_prev = deepcopy(max_value)
        if mod(iteration, 5) == 0
            println("Maximum Error of $(error) on iteration $(iteration).")
            append!(coefficients_store, [coefficients])
        end
        iteration += 1
    end
    return coefficients, max_value, coefficients_store
end
```

```
## solve_vfi (generic function with 1 method)
```

---

# Step 5: Loop


```julia
solution_coeffs, max_value, intermediate_coefficients = 
    solve_vfi(params, basis_inverse, basis_matrix, grid, capital_grid, coefficients)
```

```
## Maximum Error of 0.2737801075761883 on iteration 5.
## Maximum Error of 10.181402299701638 on iteration 10.
## Maximum Error of 0.24010896371104573 on iteration 15.
## Maximum Error of 0.08969271235173859 on iteration 20.
## Maximum Error of 0.04951271957737897 on iteration 25.
## Maximum Error of 0.031335744632027096 on iteration 30.
## Maximum Error of 0.02124544109347175 on iteration 35.
## Maximum Error of 0.015000169652694507 on iteration 40.
## Maximum Error of 0.010869867868583969 on iteration 45.
## Maximum Error of 0.008016830712855458 on iteration 50.
## Maximum Error of 0.0059861989167673026 on iteration 55.
## Maximum Error of 0.004509877146521781 on iteration 60.
## Maximum Error of 0.0034198806821233935 on iteration 65.
## Maximum Error of 0.0026059187406616727 on iteration 70.
## Maximum Error of 0.001992913806429802 on iteration 75.
## Maximum Error of 0.001528298601676595 on iteration 80.
## Maximum Error of 0.0011744475125273625 on iteration 85.
## Maximum Error of 0.0009039617707066463 on iteration 90.
## Maximum Error of 0.0006966193080105799 on iteration 95.
## Maximum Error of 0.0005373371780118751 on iteration 100.
## Maximum Error of 0.00041477290357942395 on iteration 105.
## Maximum Error of 0.0003203422150018359 on iteration 110.
## Maximum Error of 0.0002475159621255567 on iteration 115.
## Maximum Error of 0.00019130889470004935 on iteration 120.
## Maximum Error of 0.00014790315766932002 on iteration 125.
## Maximum Error of 0.00011436811226017789 on iteration 130.
```

```
## ([-194.522, 14.1413, -2.66324, 0.575256, -0.134034, 0.0344675, -0.00799708], [-182.756, -184.216, -187.237, -191.985, -198.441, -205.762, -211.259], Array{T,1} where T[[0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1], [46.5073, 7.85518, -1.59278, 0.349952, -0.078987, 0.0174254, -0.00346848], [-7.65552, 12.297, -2.38151, 0.525487, -0.124571, 0.0307752, -0.00663628], [-50.0685, 13.6042, -2.58269, 0.562034, -0.132302, 0.0337529, -0.00764398], [-82.8567, 13.9846, -2.63927, 0.571235, -0.133559, 0.0342889, -0.00789938], [-108.206, 14.0957, -2.65616, 0.574042, -0.133889, 0.034416, -0.00796877], [-127.813, 14.1281, -2.66118, 0.574898, -0.133991, 0.0344524, -0.00798883], [-142.982, 14.1375, -2.66264, 0.575151, -0.134022, 0.0344631, -0.00799468], [-154.718, 14.1402, -2.66307, 0.575226, -0.134031, 0.0344662, -0.00799639], [-163.8, 14.141, -2.66319, 0.575247, -0.134033, 0.0344671, -0.00799688]  …  [-190.871, 14.1413, -2.66324, 0.575256, -0.134034, 0.0344675, -0.00799708], [-191.774, 14.1413, -2.66324, 0.575256, -0.134034, 0.0344675, -0.00799708], [-192.472, 14.1413, -2.66324, 0.575256, -0.134034, 0.0344675, -0.00799708], [-193.013, 14.1413, -2.66324, 0.575256, -0.134034, 0.0344675, -0.00799708], [-193.431, 14.1413, -2.66324, 0.575256, -0.134034, 0.0344675, -0.00799708], [-193.755, 14.1413, -2.66324, 0.575256, -0.134034, 0.0344675, -0.00799708], [-194.006, 14.1413, -2.66324, 0.575256, -0.134034, 0.0344675, -0.00799708], [-194.2, 14.1413, -2.66324, 0.575256, -0.134034, 0.0344675, -0.00799708], [-194.35, 14.1413, -2.66324, 0.575256, -0.134034, 0.0344675, -0.00799708], [-194.466, 14.1413, -2.66324, 0.575256, -0.134034, 0.0344675, -0.00799708]])
```

---

# Now lets plot our solutions


```julia
scale_capital(capital) = 2*(capital - params.capital_lower)/(params.capital_upper - params.capital_lower) - 1
```

```
## scale_capital (generic function with 1 method)
```

```julia
capital_levels = range(params.capital_lower, params.capital_upper, length = 100);
eval_points = scale_capital.(capital_levels);

solution = similar(intermediate_coefficients);

# Compute optimal value at all capital grid points
for (iteration, coeffs) in enumerate(intermediate_coefficients)
    solution[iteration] = [coeffs' * [cheb_polys.(capital, n) for n = 0:params.num_points - 1] for capital in eval_points];
end
```

---

# Plot the value function iterations

&lt;img src="6_solution_methods_files/figure-html/unnamed-chunk-10-J1.png" width="800" /&gt;

---

# Plot the value function iterations

&lt;img src="6_solution_methods_files/figure-html/unnamed-chunk-11-J1.png" width="800" /&gt;

---

# Plot the value function iterations

&lt;img src="6_solution_methods_files/figure-html/unnamed-chunk-12-J1.png" width="800" /&gt;

---

# Plot the value function iterations

&lt;img src="6_solution_methods_files/figure-html/unnamed-chunk-13-J1.png" width="800" /&gt;

---

# Plot the value function iterations

&lt;img src="6_solution_methods_files/figure-html/unnamed-chunk-14-J1.png" width="800" /&gt;

---

# Plot the value function iterations

&lt;img src="6_solution_methods_files/figure-html/unnamed-chunk-15-J1.png" width="800" /&gt;

---

# Plot the value function iterations

&lt;img src="6_solution_methods_files/figure-html/unnamed-chunk-16-J1.png" width="800" /&gt;

---

# Plot the value function iterations

&lt;img src="6_solution_methods_files/figure-html/unnamed-chunk-17-J1.png" width="800" /&gt;

---

# Plot the value function iterations

&lt;img src="6_solution_methods_files/figure-html/unnamed-chunk-18-J1.png" width="800" /&gt;

---

# Plot the final value function

&lt;img src="6_solution_methods_files/figure-html/unnamed-chunk-19-J1.png" width="800" /&gt;

---

# Now lets try simulating


```julia
function simulate_model(params, solution_coeffs, time_horizon = 100)
    capital_store = zeros(time_horizon + 1)
    consumption_store = zeros(time_horizon)
    capital_store[1] = params.k_0
    
    for t = 1:time_horizon
        capital = capital_store[t]
        function bellman(consumption)
            capital_next = capital^params.alpha - consumption
            capital_next_scaled = scale_capital(capital_next)
            cont_value = solution_coeffs' * [cheb_polys.(capital_next_scaled, n) for n = 0:params.num_points - 1]
            value_out = (consumption)^(1-params.eta)/(1-params.eta) + params.beta*cont_value
            return -value_out
        end;

        results = optimize(bellman, 0.0, capital^params.alpha)

        # Compute new value
        consumption_store[t] = Optim.minimizer(results)
        capital_store[t+1] = capital^params.alpha - consumption_store[t]
    end

    return consumption_store, capital_store
end;
```

---

# Now lets try simulating

&lt;img src="6_solution_methods_files/figure-html/unnamed-chunk-21-J1.png" width="800" /&gt;

---

# The consumption policy function


```julia
capital_levels = range(params.capital_lower, params.capital_upper, length = 100);
consumption = similar(capital_levels);

# Compute optimal consumption at all capital grid points
for (iteration, capital) in enumerate(capital_levels)

    function bellman(consumption)
        capital_next = capital^params.alpha - consumption
        capital_next_scaled = scale_capital(capital_next)
        cont_value = solution_coeffs' * [cheb_polys.(capital_next_scaled, n) for n = 0:params.num_points - 1]
        value_out = (consumption)^(1-params.eta)/(1-params.eta) + params.beta*cont_value
        return -value_out
    end

    results = optimize(bellman, 0., capital^params.alpha)

    consumption[iteration] = Optim.minimizer(results)
end;
```

---

# The consumption policy function

&lt;img src="6_solution_methods_files/figure-html/unnamed-chunk-23-J1.png" width="800" /&gt;

---

# Method 2: Fixed point iteration

In FPI we generally approximate a *policy function* with some flexible functional form `\(\Gamma(k_t;b)\)` where `\(b\)` is a vector of coefficients

--

FPI re-casts equilibrium conditions of the model as a fixed point

--

We then perform multi-dimensional function iteration to solve for the fixed point

--

This ends up being very simple and it works on any dimension function

--

It is also does not bear a terrible computational cost and is derivative-free

--

The drawback is that it will not always converge and is generally unstable

--

This can be solved by **damping**


---

# Eq condition: Euler equation

Often we will iterate on the Euler equation which for our problem is
`$$u'(c_t) = \beta u'(c_{t+1}) f'(k_{t+1})$$`

--

We need to put this in a fixed point form in order to iterate on it
`$$c_t = u'^{(-1)}\left(\beta u'(c_{t+1}) f'(k_{t+1})\right)$$`

--

How do we solve this?

--

We approximate the consumption policy function `\(c_{t} = C(k_t)\)` with some flexible functional form `\(\Psi(k_t; b)\)`

--

We have defined `\(c_{t}\)` in two ways, once as an outcome of the policy function, and once as an equilibrium condition

--

Now we can form our consumption policy function as a fixed point by substituting `\(C(k_t)\)` into the the Euler fixed point as follows
`$$C(k_t) = u'^{(-1)}\left(\beta u'(C(k_{t+1})) f'(k_{t+1}(C(k_t),k_t))\right)$$`

---

# Method 2: Fixed point iteration

The algorithm:

1. Select the number of collocation points in each dimension and the domain of the approximation space
2. Select an initial vector of coefficients `\(b_0\)` with the same number of elements as the collocation grid
3. Select a rule for convergence
4. Construct the grid and basis matrix
5. While convergence criterion `\(&gt;\)` tolerance
  + Start iteration `\(p\)`
  + Substitute `\(C(k_{t+1};b^{(p)})\)` into the right hand side of the Euler fixed point
  + Recover the LHS values of consumption at each grid point, conditional on `\(C(k_{t+1};b^{(p)})\)`
  + Fit the polynomial to the values and recover a new vector of coefficients `\(\hat{b}^{(p+1)}\)`.
  + Compute the vector of coefficients `\(b^{(p+1)}\)` for iteration `\(p+1\)` by  
  `\(b^{(p+1)} = (1-\gamma) b^{(p)} + \gamma \hat{b}^{(p+1)}\)` where `\(\gamma \in (0,1).\)` (damping)
6. Error check your approximation

--

Notice: we did not have to perform a maximization step **anywhere**, this leads to big speed gains

---

# Step 1: Select the number of points and domain

Put everything in a **named tuple** to make passing things easier


```julia
using LinearAlgebra, Optim, Plots
params_fpi = (alpha = 0.75, beta = 0.95, eta = 2, damp = 0.5,
                steady_state = (0.75*0.95)^(1/(1-0.75)), k_0 = (0.75*0.95)^(1/(1-0.75))*0.5,
                capital_upper = (0.75*0.95)^(1/(1-0.75))*1.5, capital_lower = (0.75*0.95)^(1/(1-0.75))*0.5,
                num_points = 5, tolerance = 0.00001)
```

```
## (alpha = 0.75, beta = 0.95, eta = 2, damp = 0.5, steady_state = 0.25771486816406236, k_0 = 0.12885743408203118, capital_upper = 0.3865723022460935, capital_lower = 0.12885743408203118, num_points = 5, tolerance = 1.0e-5)
```

```julia
scale_capital(capital) = 2*(capital - params_fpi.capital_lower)/(params_fpi.capital_upper - params_fpi.capital_lower) - 1
```

```
## scale_capital (generic function with 1 method)
```

---

# Step 2: Select an initial vector of coefficients `\(b_0\)`


```julia
coefficients = zeros(params_fpi.num_points)
```

```
## 5-element Array{Float64,1}:
##  0.0
##  0.0
##  0.0
##  0.0
##  0.0
```

---

# Step 3: Select a convergence rule

Rule: maximum change in value on the grid &lt; 0.001%

---

# Step 4: Construct the grid and matrix of basis functions


```julia
function cheb_nodes(n)
    nodes = [cos.(pi * (2k - 1)/(2n)) for k = 1:n]
end;
grid = cheb_nodes(params_fpi.num_points);
capital_grid = (1 .+ grid)*(params_fpi.capital_upper - params_fpi.capital_lower)/2 .+ params_fpi.capital_lower # actual capital grid
```

```
## 5-element Array{Float64,1}:
##  0.3802655705208513 
##  0.33345536756572974
##  0.2577148681640623 
##  0.18197436876239492
##  0.1351641658072734
```

---

# Step 4: Construct the grid and basis matrix


```julia
# Chebyshev polynomial function
function cheb_polys(x, n)
    if n == 0
        return 1                    # T_0(x) = 1
    elseif n == 1
        return x                    # T_1(x) = x
    else
        cheb_recursion(x, n) =
            2x.*cheb_polys.(x, n - 1) .- cheb_polys.(x, n - 2)
        return cheb_recursion(x, n) # T_n(x) = 2xT_{n-1}(x) - T_{n-2}(x)
    end
end;
```

---

# Step 4a: Pre-invert your basis matrix

Hot tip: you will be using the exact same basis matrix in each loop iteration: just pre-invert it to save time


```julia
basis_matrix = [cheb_polys.(grid, n) for n = 0:params_fpi.num_points - 1];
basis_matrix = hcat(basis_matrix...);
basis_inverse = basis_matrix\I
```

```
## 5×5 Array{Float64,2}:
##  0.2        0.2        0.2           0.2        0.2     
##  0.380423   0.235114   5.55112e-17  -0.235114  -0.380423
##  0.323607  -0.123607  -0.4          -0.123607   0.323607
##  0.235114  -0.380423  -8.32667e-17   0.380423  -0.235114
##  0.123607  -0.323607   0.4          -0.323607   0.123607
```

---

# Step 5: Loop

Construct the Euler fixed point function

```julia
function consumption_euler(params, capital, coefficients)

    # RHS: Current consumption given current capital
    consumption = coefficients' * [cheb_polys.(scale_capital(capital), n) for n = 0:params.num_points - 1]

    # RHS: Next period's capital given current capital and consumption
    capital_next = capital^params.alpha - consumption

    # RHS: Next period's consumption given current capital and consumption
    consumption_next = coefficients' * [cheb_polys.(scale_capital(capital_next), n) for n = 0:params.num_points - 1]
    consumption_next = max(1e-10, consumption_next)

    # LHS: Next period's consumption from Euler equation
    consumption_lhs = (
        params.beta *
        consumption_next^(-params.eta) *
        params.alpha*(capital_next).^(params.alpha-1)
        ).^(-1/params.eta)
    return consumption_lhs
end
```

```
## consumption_euler (generic function with 1 method)
```

---

# Step 5: Loop

Construct a function that loops over the grid points and solves the Euler given `\(\Psi(x;b^{(p)})\)`


```julia
function loop_grid_fpi(params, basis_inverse, basis_matrix, grid, capital_grid, coefficients)

    consumption = similar(coefficients)

    # Compute next period's consumption from the Euler equation
    for (iteration, capital) in enumerate(capital_grid)
        consumption[iteration] = consumption_euler(params, capital, coefficients)
    end
    return consumption
end
```

```
## loop_grid_fpi (generic function with 1 method)
```

---

# Step 5: Loop


```julia
function solve_fpi(params, basis_inverse, basis_matrix, grid, capital_grid, coefficients)
    error = 1e10
    iteration = 1
    consumption = similar(coefficients)
    consumption_prev = similar(coefficients)
    coefficients_prev = similar(coefficients)
    coefficients_store = Vector{Vector}(undef, 1)
    coefficients_store[1] = coefficients
    while error &gt; params.tolerance
        consumption = loop_grid_fpi(params, basis_inverse, basis_matrix, grid, capital_grid, coefficients)
        if iteration &gt; 1
            coefficients = params.damp*(basis_inverse*consumption) + (1 - params.damp)*coefficients_prev
        else
            coefficients = basis_inverse*consumption
        end
        error = maximum(abs.((consumption - consumption_prev)./(consumption_prev)))
        coefficients_prev = deepcopy(coefficients)
        consumption_prev = deepcopy(consumption)
        if mod(iteration, 5) == 0
            println("Maximum Error of $(error) on iteration $(iteration).")
            append!(coefficients_store, [coefficients])
        end
        iteration += 1
    end
    return coefficients, consumption, coefficients_store
end
```

```
## solve_fpi (generic function with 1 method)
```

---

# Step 5: Loop


```julia
solution_coeffs, consumption, intermediate_coefficients =
    solve_fpi(params_fpi, basis_inverse, basis_matrix, grid, capital_grid, coefficients)
```

```
## Maximum Error of 0.04848154313777527 on iteration 5.
## Maximum Error of 0.9180423909010798 on iteration 10.
## Maximum Error of 0.6785900670471697 on iteration 15.
## Maximum Error of 0.3515179307657073 on iteration 20.
## Maximum Error of 0.21082481614861703 on iteration 25.
## Maximum Error of 0.13722914501426453 on iteration 30.
## Maximum Error of 0.8151356271104383 on iteration 35.
## Maximum Error of 1.9746925798283417 on iteration 40.
## Maximum Error of 0.6076716985274082 on iteration 45.
## Maximum Error of 0.2879644038542271 on iteration 50.
## Maximum Error of 0.1892911080507604 on iteration 55.
## Maximum Error of 0.1093381298578999 on iteration 60.
## Maximum Error of 179325.2294038149 on iteration 65.
## Maximum Error of 1.1586750214903812 on iteration 70.
## Maximum Error of 0.4294716419658693 on iteration 75.
## Maximum Error of 0.22191043193181803 on iteration 80.
## Maximum Error of 0.1432901345644567 on iteration 85.
## Maximum Error of 0.07585569547990628 on iteration 90.
## Maximum Error of 2.5258644210144177e8 on iteration 95.
## Maximum Error of 0.4181764419583226 on iteration 100.
## Maximum Error of 0.04990349910093245 on iteration 105.
## Maximum Error of 0.017029092693825177 on iteration 110.
## Maximum Error of 0.006832144928472335 on iteration 115.
## Maximum Error of 0.0033509265924215018 on iteration 120.
## Maximum Error of 0.0016872853330860838 on iteration 125.
## Maximum Error of 0.0008241527550163533 on iteration 130.
## Maximum Error of 0.00039531946155805007 on iteration 135.
## Maximum Error of 0.00018765907251506992 on iteration 140.
## Maximum Error of 8.85615214960375e-5 on iteration 145.
## Maximum Error of 4.1657730962667196e-5 on iteration 150.
## Maximum Error of 1.9559109901747855e-5 on iteration 155.
## Maximum Error of 9.1739373754161e-6 on iteration 160.
```

```
## ([0.10216, 0.0304916, -0.00186149, 0.000241209, -3.67407e-5], [0.129785, 0.120459, 0.103985, 0.085072, 0.0715016], Array{T,1} where T[[0.0, 0.0, 0.0, 0.0, 0.0], [1.21006e-10, 9.563e-12, -3.11245e-12, -8.45646e-14, -7.16761e-14], [1.63158e-10, 5.90729e-11, 2.95981e-11, 8.83107e-12, 6.0298e-13], [1.46648e-9, 1.21746e-9, 1.62343e-10, 2.15585e-12, -1.65855e-13], [6.6381e-9, 3.58878e-9, 8.01528e-11, -7.57041e-13, 4.593e-13], [1.75354e-8, 6.64997e-9, -1.89569e-10, 1.50556e-11, -5.24361e-12], [3.30229e-8, 7.28446e-9, -1.35862e-9, -2.4313e-11, -1.89576e-11], [3.06787e-8, -1.15984e-8, -4.79071e-9, -1.0933e-10, -4.39929e-11], [2.61422e-7, 3.12463e-7, 9.09027e-8, 9.34814e-9, 6.16241e-11], [2.72196e-6, 1.99399e-6, 1.57867e-7, -2.86014e-9, 4.08017e-10]  …  [0.0972189, 0.0287848, -0.00175121, 0.000228442, -3.71249e-5], [0.0997479, 0.0295045, -0.00181815, 0.00023769, -3.74242e-5], [0.101004, 0.0299742, -0.00184532, 0.000240435, -3.71857e-5], [0.101614, 0.0302349, -0.00185546, 0.000241102, -3.69774e-5], [0.101905, 0.0303686, -0.00185917, 0.000241227, -3.68572e-5], [0.102043, 0.0304344, -0.00186057, 0.000241234, -3.67955e-5], [0.102108, 0.0304661, -0.00186112, 0.000241225, -3.67653e-5], [0.102139, 0.0304812, -0.00186135, 0.000241216, -3.67508e-5], [0.102153, 0.0304883, -0.00186145, 0.000241212, -3.6744e-5], [0.10216, 0.0304916, -0.00186149, 0.000241209, -3.67407e-5]])
```

---

# Now lets plot our solutions


```julia
capital_levels = range(params_fpi.capital_lower, params_fpi.capital_upper, length = 100);
eval_points = scale_capital.(capital_levels);
solution = similar(intermediate_coefficients);

for (iteration, coeffs) in enumerate(intermediate_coefficients)
    solution[iteration] = [coeffs' * [cheb_polys.(capital, n) for n = 0:params_fpi.num_points - 1] for capital in eval_points];
end
```

---

# Plot the consumption policy function

&lt;img src="6_solution_methods_files/figure-html/unnamed-chunk-34-J1.png" width="800" /&gt;

---

# Plot the consumption policy function

&lt;img src="6_solution_methods_files/figure-html/unnamed-chunk-35-J1.png" width="800" /&gt;

---

# Plot the consumption policy function

&lt;img src="6_solution_methods_files/figure-html/unnamed-chunk-36-J1.png" width="800" /&gt;

---

# Plot the consumption policy function

&lt;img src="6_solution_methods_files/figure-html/unnamed-chunk-37-J1.png" width="800" /&gt;

---

# Plot the consumption policy function

&lt;img src="6_solution_methods_files/figure-html/unnamed-chunk-38-J1.png" width="800" /&gt;

---

# Plot the consumption policy function

&lt;img src="6_solution_methods_files/figure-html/unnamed-chunk-39-J1.png" width="800" /&gt;

---

# Plot the consumption policy function

&lt;img src="6_solution_methods_files/figure-html/unnamed-chunk-40-J1.png" width="800" /&gt;

---

# Plot the consumption policy function

&lt;img src="6_solution_methods_files/figure-html/unnamed-chunk-41-J1.png" width="800" /&gt;

---

# Plot the consumption policy function

&lt;img src="6_solution_methods_files/figure-html/unnamed-chunk-42-J1.png" width="800" /&gt;

---

# Plot the final consumption policy function

&lt;img src="6_solution_methods_files/figure-html/unnamed-chunk-43-J1.png" width="800" /&gt;

---

# Now lets try simulating


```julia
function simulate_model(params, solution_coeffs, time_horizon = 100)
    capital_store = zeros(time_horizon + 1)
    consumption_store = zeros(time_horizon)
    capital_store[1] = params.k_0

    for t = 1:time_horizon
        capital = capital_store[t]
        consumption_store[t] = consumption_euler(params, capital, solution_coeffs)
        capital_store[t+1] = capital^params.alpha - consumption_store[t]
    end

    return consumption_store, capital_store

end
```

```
## simulate_model (generic function with 2 methods)
```

---

# Now lets try simulating


```julia
time_horizon = 100;
consumption, capital = simulate_model(params_fpi, solution_coeffs, time_horizon);
plot(1:time_horizon, consumption, color = :red, linewidth = 4.0, tickfontsize = 14, guidefontsize = 14, label = "Consumption", legend = :right, grid = false, size = (500, 300));
plot!(1:time_horizon, capital[1:end-1], color = :blue, linewidth = 4.0, linestyle = :dash, label = "Capital");
plot!(1:time_horizon, params_fpi.steady_state*ones(time_horizon), color = :purple, linewidth = 2.0, linestyle = :dot, label = "Steady State Capital")
```

&lt;img src="6_solution_methods_files/figure-html/unnamed-chunk-45-J1.png" width="667" /&gt;

---

# Method 3: Time iteration

In TI we approximate the *policy function* with some flexible functional form `\(\Psi(k_t;b)\)` where `\(b\)` is a vector of coefficients

--

The difference vs FPI is we use root-finding techniques on our `\(n\)` node collocation grid where  
we search for the scalar `\(c^{(p+1)}(k_t)\)` that solves
`$$u'(c^{(p+1)}(k^j_t)) = \beta u'(C^{(p)}(f(k^j_t)-c^{(p+1)}(k^j_t))) f'(f(k^i_t)-c^{(p+1)}(k^j_t)) \,\,\,\, \text{for j } = 1,...,n$$`

--

`\(C^{(p)}()\)` is our current approximation to the policy function, and we are searching for a scalar `\(c^{(p+1)}(k^j_t)\)`, given our collocation node `\(k_t^j\)`, that solves the Euler equation root-finding problem

--

In the Euler equation `\(c^{(p+1)}\)` corresponds to today's policy function  
while `\(C^{(p)}\)` corresponds to tomorrow's policy function: we are searching for today's policy that satisfies the Euler equation

--

As we iterate and `\(p\)` increases, `\(C^{(p)}(k)\)` should converge because of a *monotonicity property*

--

If `\(C'^{(p)}(k) &gt; 0\)`, and `\(C^{(p)}(k) &lt; C^{(p-1)}(k)\)`, then `\(C^{(p+1)}(k) &lt; C^{(p)}(k)\)` and `\(C'^{(p+1)}(k) &gt; 0\)`

--

It preserves the (first-order) shape of the policy function so it is reliable and convergent

--

Unfortunately time iteration tends to be slow, especially as the number of dimensions grows

---

# Method 3: Time iteration

The algorithm:

1. Select the number of collocation points in each dimension and the domain of the approximation space
2. Select an initial vector of coefficients `\(b_0\)` with the same number of elements as the collocation grid,  
and initial guesses for consumption for the solver
3. Select a rule for convergence
4. Construct the grid and basis matrix
5. While convergence criterion `\(&gt;\)` tolerance
  + Start iteration `\(p\)`
  + Substitute `\(C(k^j_{t+1};b^{(p)})\)` into both sides
  + Recover the `\(c^{(p+1)}(k^j_t) \in \mathbb{R}\)` scalar values that satisfy the equation conditional on `\(C(k_{t+1};b^{(p)})\)`
  + Fit the polynomial to the values and recover a new vector of coefficients `\(\hat{b}^{(p+1)}\)`.
  + Compute the vector of coefficients `\(b^{(p+1)}\)` for iteration `\(p+1\)` by  
  `\(b^{(p+1)} = (1-\gamma) b^{(p)} + \gamma \hat{b}^{(p+1)}\)` where `\(\gamma \in (0,1).\)` (damping)
6. Error check your approximation

---

# Step 1: Select the number of points and domain

Put everything in a **named tuple** to make passing things easier


```julia
using LinearAlgebra, Optim, Plots, Roots
params_ti = (alpha = 0.75, beta = 0.95, eta = 2, damp = 0.7,
                steady_state = (0.75*0.95)^(1/(1-0.75)), k_0 = (0.75*0.95)^(1/(1-0.75))*0.5,
                capital_upper = (0.75*0.95)^(1/(1-0.75))*1.5, capital_lower = (0.75*0.95)^(1/(1-0.75))*0.5,
                num_points = 5, tolerance = 0.00001)
```

```
## (alpha = 0.75, beta = 0.95, eta = 2, damp = 0.7, steady_state = 0.25771486816406236, k_0 = 0.12885743408203118, capital_upper = 0.3865723022460935, capital_lower = 0.12885743408203118, num_points = 5, tolerance = 1.0e-5)
```

```julia
scale_capital(capital) = 2*(capital - params_ti.capital_lower)/(params_ti.capital_upper - params_ti.capital_lower) - 1
```

```
## scale_capital (generic function with 1 method)
```

---

# Step 2: Select an initial vector of coefficients `\(b_0\)`


```julia
coefficients = zeros(params_ti.num_points)
```

```
## 5-element Array{Float64,1}:
##  0.0
##  0.0
##  0.0
##  0.0
##  0.0
```

---

# Step 3: Select a convergence rule

Rule: maximum change in value on the grid &lt; 0.001%

---

# Step 4: Construct the grid and matrix of basis functions


```julia
function cheb_nodes(n)
    nodes = [cos.(pi * (2k - 1)/(2n)) for k = 1:n]
end;
grid = cheb_nodes(params_ti.num_points) # [-1, 1] grid
```

```
## 5-element Array{Float64,1}:
##   0.9510565162951535   
##   0.5877852522924731   
##   6.123233995736766e-17
##  -0.587785252292473    
##  -0.9510565162951535
```

```julia
capital_grid = (1 .+ grid)*(params_ti.capital_upper - params_ti.capital_lower)/2 .+ params_ti.capital_lower # actual capital grid
```

```
## 5-element Array{Float64,1}:
##  0.3802655705208513 
##  0.33345536756572974
##  0.2577148681640623 
##  0.18197436876239492
##  0.1351641658072734
```

---

# Step 4: Construct the grid and basis matrix


```julia
# Chebyshev polynomial function
function cheb_polys(x, n)
    if n == 0
        return 1                    # T_0(x) = 1
    elseif n == 1
        return x                    # T_1(x) = x
    else
        cheb_recursion(x, n) =
            2x.*cheb_polys.(x, n - 1) .- cheb_polys.(x, n - 2)
        return cheb_recursion(x, n) # T_n(x) = 2xT_{n-1}(x) - T_{n-2}(x)
    end
end;
```

---

# Step 4a: Pre-invert your basis matrix


```julia
basis_matrix = [cheb_polys.(grid, n) for n = 0:params_ti.num_points - 1];
basis_matrix = hcat(basis_matrix...);
basis_inverse = basis_matrix\I
```

```
## 5×5 Array{Float64,2}:
##  0.2        0.2        0.2           0.2        0.2     
##  0.380423   0.235114   5.55112e-17  -0.235114  -0.380423
##  0.323607  -0.123607  -0.4          -0.123607   0.323607
##  0.235114  -0.380423  -8.32667e-17   0.380423  -0.235114
##  0.123607  -0.323607   0.4          -0.323607   0.123607
```

---

# Step 5: Loop

Construct a function that loops over the grid points and solves the Euler given `\(\Psi(x;b^{(p)})\)`


```julia
function loop_grid_ti(params, basis_inverse, basis_matrix, grid, capital_grid, coefficients)

    consumption = similar(coefficients)
    
    for (iteration, capital) in enumerate(capital_grid)

        function consumption_euler(consumption_guess)
            capital_next = capital^params.alpha - consumption_guess

            # Next period consumption based on policy approximant
            consumption_next = coefficients' * [cheb_polys.(scale_capital(capital_next), n) for n = 0:params.num_points - 1]
            consumption_next = max(1e-10, consumption_next)

            # Organize Euler so it's g(c,k) = 0
            euler_error = consumption_guess^(-params.eta) / 
                (params.beta*consumption_next^(-params.eta)*params.alpha*(capital_next)^(params.alpha - 1)) - 1
            return euler_error
        end

        # Search over consumption such that Euler = 0
        consumption[iteration] = fzero(consumption_euler, 0., capital)

    end
    return consumption
end
```

```
## loop_grid_ti (generic function with 1 method)
```

---

# Step 5: Loop


```julia
function solve_ti(params, basis_inverse, basis_matrix, grid, capital_grid, coefficients)
    error = 1e10
    iteration = 1
    consumption = similar(coefficients)
    consumption_prev = similar(coefficients)
    coefficients_prev = similar(coefficients)
    coefficients_store = Vector{Vector}(undef, 1)
    coefficients_store[1] = coefficients
    while error &gt; params.tolerance
        consumption = loop_grid_ti(params, basis_inverse, basis_matrix, grid, capital_grid, coefficients)
        if iteration &gt; 1
            coefficients = params.damp*(basis_inverse*consumption) + (1 - params.damp)*coefficients_prev
        else
            coefficients = basis_inverse*consumption
        end
        error = maximum(abs.((consumption - consumption_prev)./(consumption_prev)))
        consumption_prev = deepcopy(consumption)
        coefficients_prev = deepcopy(coefficients)
        if mod(iteration, 5) == 0
            println("Maximum Error of $(error) on iteration $(iteration).")
            append!(coefficients_store, [coefficients])
        end
        iteration += 1
    end
    return coefficients, consumption, coefficients_store
end
```

```
## solve_ti (generic function with 1 method)
```

---

# Step 5: Loop


```julia
solution_coeffs, consumption, intermediate_coefficients =
    solve_ti(params_ti, basis_inverse, basis_matrix, grid, capital_grid, coefficients)
```

```
## Maximum Error of 0.06899533243252934 on iteration 5.
## Maximum Error of 1.481484067728511 on iteration 10.
## Maximum Error of 0.7160885861973345 on iteration 15.
## Maximum Error of 0.3030828724582769 on iteration 20.
## Maximum Error of 0.17473143140005473 on iteration 25.
## Maximum Error of 505.4805245124472 on iteration 30.
## Maximum Error of 1.193558398749873 on iteration 35.
## Maximum Error of 0.28476702156043676 on iteration 40.
## Maximum Error of 0.19536671877310902 on iteration 45.
## Maximum Error of 235825.18031971727 on iteration 50.
## Maximum Error of 1.4632905297050023 on iteration 55.
## Maximum Error of 0.3819128797728578 on iteration 60.
## Maximum Error of 0.2069777248265044 on iteration 65.
## Maximum Error of 0.2882977765088428 on iteration 70.
## Maximum Error of 1.5557188732619867 on iteration 75.
## Maximum Error of 0.20172230910005298 on iteration 80.
## Maximum Error of 0.06127838612896111 on iteration 85.
## Maximum Error of 0.028153777682640414 on iteration 90.
## Maximum Error of 0.014466543089840038 on iteration 95.
## Maximum Error of 0.006878960963739522 on iteration 100.
## Maximum Error of 0.003130222595497513 on iteration 105.
## Maximum Error of 0.001391461005386054 on iteration 110.
## Maximum Error of 0.0006111544900213002 on iteration 115.
## Maximum Error of 0.00026681831311659726 on iteration 120.
## Maximum Error of 0.00011614043376537828 on iteration 125.
## Maximum Error of 5.047881962395737e-5 on iteration 130.
## Maximum Error of 2.1923791129685817e-5 on iteration 135.
## Maximum Error of 9.518360650356241e-6 on iteration 140.
```

```
## ([0.10216, 0.0304922, -0.00186147, 0.000241205, -3.67394e-5], [0.129785, 0.120459, 0.103985, 0.085072, 0.0715015], Array{T,1} where T[[0.0, 0.0, 0.0, 0.0, 0.0], [1.27631e-10, 7.18378e-12, -5.17381e-12, -2.5865e-13, -8.83115e-14], [5.31714e-10, 5.52785e-10, 1.67035e-10, 1.81412e-11, -1.44782e-13], [8.31697e-9, 5.18754e-9, 2.03086e-10, -1.14914e-11, 1.70952e-12], [3.38628e-8, 1.2764e-8, -3.09125e-10, 4.02502e-11, -1.14148e-11], [7.52422e-8, 1.05702e-8, -4.4366e-9, -1.17443e-10, -4.94777e-11], [3.5815e-8, -1.44725e-8, 1.83471e-8, 5.22839e-9, -1.50423e-10], [8.64917e-7, 6.23977e-7, 2.58047e-8, -5.85306e-9, 3.60589e-10], [3.55731e-6, 1.27343e-6, -3.07228e-8, 1.08998e-8, -1.29267e-9], [8.395e-6, 1.5755e-6, -4.34529e-7, -2.04642e-8, -5.01397e-9]  …  [0.0937722, 0.0270497, -0.0017387, 0.000227151, -3.84818e-5], [0.0982859, 0.0288194, -0.00180844, 0.000237046, -3.773e-5], [0.10043, 0.0297236, -0.00183945, 0.000239957, -3.72189e-5], [0.101402, 0.0301499, -0.00185236, 0.000240796, -3.69575e-5], [0.101832, 0.0303427, -0.00185768, 0.000241058, -3.68356e-5], [0.10202, 0.0304282, -0.00185989, 0.000241149, -3.67809e-5], [0.102102, 0.0304657, -0.00186083, 0.000241183, -3.67567e-5], [0.102138, 0.030482, -0.00186123, 0.000241197, -3.67461e-5], [0.102154, 0.0304891, -0.0018614, 0.000241203, -3.67414e-5], [0.10216, 0.0304922, -0.00186147, 0.000241205, -3.67394e-5]])
```

---

# Now lets plot our solutions


```julia
capital_levels = range(params_ti.capital_lower, params_ti.capital_upper, length = 100);
eval_points = scale_capital.(capital_levels);
solution = similar(intermediate_coefficients);

for (iteration, coeffs) in enumerate(intermediate_coefficients)
    solution[iteration] = [coeffs' * [cheb_polys.(capital, n) for n = 0:params_ti.num_points - 1] for capital in eval_points];
end
```

---

# Plot the consumption policy function

&lt;img src="6_solution_methods_files/figure-html/unnamed-chunk-55-J1.png" width="800" /&gt;

---

# Plot the consumption policy function

&lt;img src="6_solution_methods_files/figure-html/unnamed-chunk-56-J1.png" width="800" /&gt;

---

# Plot the consumption policy function

&lt;img src="6_solution_methods_files/figure-html/unnamed-chunk-57-J1.png" width="800" /&gt;

---

# Plot the consumption policy function

&lt;img src="6_solution_methods_files/figure-html/unnamed-chunk-58-J1.png" width="800" /&gt;

---

# Plot the consumption policy function

&lt;img src="6_solution_methods_files/figure-html/unnamed-chunk-59-J1.png" width="800" /&gt;

---

# Plot the consumption policy function

&lt;img src="6_solution_methods_files/figure-html/unnamed-chunk-60-J1.png" width="800" /&gt;

---

# Plot the consumption policy function

&lt;img src="6_solution_methods_files/figure-html/unnamed-chunk-61-J1.png" width="800" /&gt;

---

# Plot the consumption policy function

&lt;img src="6_solution_methods_files/figure-html/unnamed-chunk-62-J1.png" width="800" /&gt;

---

# Plot the consumption policy function

&lt;img src="6_solution_methods_files/figure-html/unnamed-chunk-63-J1.png" width="800" /&gt;

---

# Plot the final consumption policy function

&lt;img src="6_solution_methods_files/figure-html/unnamed-chunk-64-J1.png" width="800" /&gt;

---

# Now lets try simulating


```julia
function simulate_model(params, solution_coeffs, time_horizon = 100)
    capital_store = zeros(time_horizon + 1)
    consumption_store = zeros(time_horizon)
    capital_store[1] = params.k_0

    for t = 1:time_horizon
        capital = capital_store[t]
        consumption_store[t] = solution_coeffs' * [cheb_polys.(scale_capital(capital), n) for n = 0:params.num_points - 1]
        capital_store[t+1] = capital^params.alpha - consumption_store[t]
    end

    return consumption_store, capital_store
end;
```

---

# Now lets try simulating


```julia
time_horizon = 100;
consumption, capital = simulate_model(params_ti, solution_coeffs, time_horizon);
plot(1:time_horizon, consumption, color = :red, linewidth = 4.0, tickfontsize = 14, guidefontsize = 14, label = "Consumption", legend = :right, grid = false, size = (500, 300));
plot!(1:time_horizon, capital[1:end-1], color = :blue, linewidth = 4.0, linestyle = :dash, label = "Capital");
plot!(1:time_horizon, params_ti.steady_state*ones(time_horizon), color = :purple, linewidth = 2.0, linestyle = :dot, label = "Steady State Capital")
```

&lt;img src="6_solution_methods_files/figure-html/unnamed-chunk-66-J1.png" width="667" /&gt;

---

# A short overview of discretization + VFI

When we use discretization methods we create a grid on our state space, typically evenly spaced

--

This becomes our **actual** state space, not just collocation points

--

How does it work?

--

The discretized state space implies a discretized control space

--

If there are only a finite number of states tomorrow conditional on the current state,  
then there is only a finite number of valid controls

--

This makes solving easy!

--

Search over all possible controls today until you find the one that yields the highest value of the RHS of the Bellman:  
just requires looping and a max operator

--

The maximized value is the new value of this discretized state

--

3 loops now: outer VFI loop, middle capital grid loop, inner consumption loop

---

# Discretizing the state space


```julia
using LinearAlgebra, Optim, Plots 
params_dis = (alpha = 0.75, beta = 0.95, eta = 2,
                steady_state = (0.75*0.95)^(1/(1 - 0.75)), k_0 = (0.75*0.95)^(1/(1 - 0.75))*.75,
                capital_upper = (0.75*0.95)^(1/(1 - 0.75))*1.5, capital_lower = (0.75*0.95)^(1/(1 - 0.75))/2,
                tolerance = 0.0001, max_iterations = 1000)
```

```
## (alpha = 0.75, beta = 0.95, eta = 2, steady_state = 0.25771486816406236, k_0 = 0.19328615112304676, capital_upper = 0.3865723022460935, capital_lower = 0.12885743408203118, tolerance = 0.0001, max_iterations = 1000)
```

---

# Discretizing the state space


```julia
function iterate_value(grid, params) 
    grid_size = size(grid, 1)
    V = zeros(grid_size, 1)
    V_prev = zeros(grid_size, 1)
    V_store = Array{Float64}(undef, grid_size, params.max_iterations)
    max_diff = 1e10
    it = 1
    while max_diff &gt; params.tolerance &amp;&amp; it &lt;= params.max_iterations
        for (iteration, grid_point) in enumerate(grid)
            # possible consumption values (output + remaining capital - capital next period)
            c_vec = grid_point.^params.alpha .- grid
            value_max = -Inf
            # loop over possible consumption values and find the one that maximizes
            # the right hand side of the Bellman, search over ones with positive consumption
            for (it_inner, consumption) in enumerate(c_vec[c_vec .&gt; 0])
                value_temp = consumption^(1 - params.eta)/(1 - params.eta) + params.beta*V[it_inner]
                value_max = max(value_temp, value_max)
            end
            V[iteration] = value_max
        end
        max_diff = maximum(abs.(V .- V_prev))
        if mod(it,10) == 0
            println("Current maximum value difference at iteration $it is $max_diff.")
        end
        V_prev = copy(V)
        V_store[:,it] = V
        if it == params.max_iterations
            println("Hit maximum iterations")
            break
        end
        it += 1
    end
    V_store = V_store[:, 1:it-1]
    return V, V_store
end
```

```
## iterate_value (generic function with 1 method)
```

---

# Discretizing the state space


```julia
        max_diff = maximum(abs.((V .- V_prev)./V_prev))
        if mod(it,10) == 0
            println("Current maximum value difference at iteration $it is $max_diff.")
        end
        V_prev = copy(V)
        V_store[:,it] = V
        if it == params.max_iterations
            println("Hit maximum iterations")
            break
        end
        it += 1
    end
    V_store = V_store[:, 1:it-1]
    return V, V_store
end
```

---

# Discretizing the state space


```julia
grid_size = 3;
grid = collect(range(params_dis.capital_lower, 
    stop = params_dis.capital_upper, 
    length = grid_size))
```

```
## 3-element Array{Float64,1}:
##  0.12885743408203118
##  0.25771486816406236
##  0.3865723022460935
```

```julia

value, v_store = @time iterate_value(grid, params_dis)
```

```
## Current maximum value difference at iteration 10 is 7.310316889342374.
## Current maximum value difference at iteration 20 is 4.376956759187493.
## Current maximum value difference at iteration 30 is 2.6206456931746516.
## Current maximum value difference at iteration 40 is 1.5690773811596443.
## Current maximum value difference at iteration 50 is 0.9394645886236788.
## Current maximum value difference at iteration 60 is 0.5624921523154001.
## Current maximum value difference at iteration 70 is 0.33678482962292833.
## Current maximum value difference at iteration 80 is 0.20164551807033604.
## Current maximum value difference at iteration 90 is 0.12073262030057208.
## Current maximum value difference at iteration 100 is 0.07228707954499214.
## Current maximum value difference at iteration 110 is 0.043280944753263384.
## Current maximum value difference at iteration 120 is 0.0259139003889004.
## Current maximum value difference at iteration 130 is 0.015515609402569908.
## Current maximum value difference at iteration 140 is 0.009289768484109118.
## Current maximum value difference at iteration 150 is 0.005562127548415674.
## Current maximum value difference at iteration 160 is 0.0033302512239856696.
## Current maximum value difference at iteration 170 is 0.0019939444247540905.
## Current maximum value difference at iteration 180 is 0.0011938481818845048.
## Current maximum value difference at iteration 190 is 0.0007148010063247057.
## Current maximum value difference at iteration 200 is 0.00042797776669090126.
## Current maximum value difference at iteration 210 is 0.0002562460981039294.
## Current maximum value difference at iteration 220 is 0.00015342400445206295.
##   0.115471 seconds (200.55 k allocations: 12.423 MiB)
```

```
## ([-231.98; -192.324; -187.008], [-11.5991 -22.6182 … -231.98 -231.98; -9.61629 -18.7518 … -192.324 -192.324; -9.6447 -18.8072 … -187.008 -187.008])
```

---

# The value function: every 20 iterations

&lt;img src="6_solution_methods_files/figure-html/unnamed-chunk-71-J1.png" width="800" /&gt;

---

# The value function: final

&lt;img src="6_solution_methods_files/figure-html/unnamed-chunk-72-J1.png" width="800" /&gt;

---

# Discretizing the state space


```julia
grid_size = 100;
grid = collect(range(params_dis.capital_lower, 
    stop = params_dis.capital_upper, 
    length = grid_size));

value, v_store = @time iterate_value(grid, params_dis)
```

```
## Current maximum value difference at iteration 10 is 6.914720355073825.
## Current maximum value difference at iteration 20 is 3.8092197025250414.
## Current maximum value difference at iteration 30 is 2.221007019891772.
## Current maximum value difference at iteration 40 is 1.3164056274758593.
## Current maximum value difference at iteration 50 is 0.7840556792955624.
## Current maximum value difference at iteration 60 is 0.4679885486935973.
## Current maximum value difference at iteration 70 is 0.27994507576624983.
## Current maximum value difference at iteration 80 is 0.16751908240780722.
## Current maximum value difference at iteration 90 is 0.1002998626648548.
## Current maximum value difference at iteration 100 is 0.05997003214901042.
## Current maximum value difference at iteration 110 is 0.03590627349490205.
## Current maximum value difference at iteration 120 is 0.0214984122918338.
## Current maximum value difference at iteration 130 is 0.01287189357412899.
## Current maximum value difference at iteration 140 is 0.007706878160803399.
## Current maximum value difference at iteration 150 is 0.004614392641116183.
## Current maximum value difference at iteration 160 is 0.0027628073264054365.
## Current maximum value difference at iteration 170 is 0.0016541948023416353.
## Current maximum value difference at iteration 180 is 0.0009904275328835865.
## Current maximum value difference at iteration 190 is 0.0005930055496037312.
## Current maximum value difference at iteration 200 is 0.00035505432774129986.
## Current maximum value difference at iteration 210 is 0.00021258414147951044.
## Current maximum value difference at iteration 220 is 0.0001272819782229817.
##   0.212330 seconds (159.36 k allocations: 132.605 MiB, 36.64% gc time)
```

```
## ([-212.429; -211.764; … ; -183.072; -182.928], [-11.5991 -22.6182 … -212.429 -212.429; -11.5126 -22.4497 … -211.764 -211.764; … ; -9.63309 -18.7845 … -183.072 -183.072; -9.6447 -18.8072 … -182.928 -182.928])
```

---

# The value function: every 20 iterations

&lt;img src="6_solution_methods_files/figure-html/unnamed-chunk-74-J1.png" width="800" /&gt;

---

# The value function: final

&lt;img src="6_solution_methods_files/figure-html/unnamed-chunk-75-J1.png" width="800" /&gt;
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "bash",
"highlightLines": true,
"countIncrementalSlides": false,
"ratio": "16:9"
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();</script>

<script>
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
